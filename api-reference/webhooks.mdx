---
title: "Webhooks API"
description: "Set up and manage real-time event notifications for your CallIntel integration using webhooks"
---

# Webhooks API

Webhooks provide real-time HTTP notifications for events in your CallIntel account. Configure your endpoint to receive instant updates when events occur.

## Overview

<Info>
Webhooks are ideal for building responsive, event-driven applications that react to CallIntel events in real-time.
</Info>

### Key Features

- **Reliable Delivery**: 3 automatic retry attempts with exponential backoff
- **Fast Response**: 5-second timeout for optimal performance
- **Secure by Default**: HMAC-SHA256 signature verification for all events

## Prerequisites

Before you begin, ensure you have:

- A CallIntel account with admin access
- A publicly accessible HTTPS endpoint
- Basic understanding of HTTP requests and webhooks

## How Webhooks Work

1. **Configure Your Webhook URL**  
   Add your webhook endpoint URL in the organization settings under webhook configuration.

2. **Event Occurs**  
   The system triggers a webhook notification when an event occurs (e.g., call completes, transcript ready).

3. **Receive & Verify**  
   Your endpoint receives an HTTP POST request with event data. Verify the signature to ensure authenticity.

4. **Process & Respond**  
   Process the event data and return a 2xx status code within 5 seconds.

## Webhook Request Format

### Headers

```http
Content-Type: application/json
X-Webhook-Signature: sha256=<signature>
```

### Request Body

```json
{
  "event_type": "call_status_changed",
  "body": {
    "call_id": "call_123",
    "status": "completed",
    "timestamp": "2025-10-31T11:15:00Z"
  }
}
```

<Warning>
Your webhook endpoint must respond with a 2xx status code within 5 seconds. For longer processing times, implement asynchronous handling using a message queue.
</Warning>

## Available Events

### `call_status_changed`
Triggered when a call's status changes (e.g., initiated, ringing, answered, completed, failed).

<CodeGroup>
<CodeGroupItem title="Example Payload">

```json
{
  "event_type": "call_status_changed",
  "body": {
    "id": "call_abc123",
    "call_to": "+1234567890",
    "call_from": "+0987654321",
    "start_time": "2025-10-28T10:00:00Z",
    "end_time": "2025-10-28T10:05:30Z",
    "duration_seconds": 330,
    "direction": "outbound",
    "call_type": "automated",
    "batch_call_id": "batch_xyz789",
    "agent_name": "Sales Agent",
    "status": "completed"
  }
}
```

</CodeGroupItem>
</CodeGroup>

### `call_transcript`
Triggered when call transcript, summary, and actionable items are ready after a call ends.

<CodeGroup>
<CodeGroupItem title="Example Payload">

```json
{
  "event_type": "call_transcript",
  "body": {
    "id": "transcript_def456",
    "call_id": "call_abc123",
    "transcript": "Agent: Hello, this is Sales Agent calling...\nCustomer: Hi, yes...",
    "summary": "Customer expressed interest in the premium plan. Follow-up scheduled for next week.",
    "actionable": "Schedule follow-up call, Send pricing details via email"
  }
}
```

</CodeGroupItem>
</CodeGroup>

### `batch_call_status_changed`
Triggered when a batch call campaign status changes (e.g., scheduled, in_progress, completed, cancelled).

<CodeGroup>
<CodeGroupItem title="Example Payload">

```json
{
  "event_type": "batch_call_status_changed",
  "body": {
    "id": "batch_xyz789",
    "status": "in_progress",
    "agent_name": "Sales Agent",
    "total_numbers": 150,
    "name": "Q4 Sales Campaign",
    "call_from": "phone_num_123",
    "to_number_list": [
      "+1234567890",
      "+1234567891",
      "+1234567892"
    ],
    "created_at": "2025-10-28T09:00:00Z",
    "scheduled_time": "2025-10-28T10:00:00Z"
  }
}
```

</CodeGroupItem>
</CodeGroup>

## Security

### Webhook Security

#### Signature Verification

Every webhook request includes an `X-Webhook-Signature` header containing an HMAC-SHA256 signature. Always verify this signature to ensure the request originated from CallIntel and hasn't been tampered with.

#### Signature Format
```
sha256=<hex_encoded_hmac>
```

#### Verification Process
1. Extract the signature from the `X-Webhook-Signature` header
2. Compute HMAC-SHA256 of the raw request body using your webhook secret
3. Prepend "sha256=" to your computed hash
4. Compare using a constant-time comparison function to prevent timing attacks

<CodeGroup>
<CodeGroupItem title="Node.js Example">

```javascript
const crypto = require('crypto');

function verifyWebhook(payload, signature, secret) {
  const hmac = crypto.createHmac('sha256', secret);
  const digest = 'sha256=' + hmac.update(JSON.stringify(payload)).digest('hex');
  
  return crypto.timingSafeEqual(
    Buffer.from(signature),
    Buffer.from(digest)
  );
}
```

</CodeGroupItem>

<CodeGroupItem title="Express.js Middleware">

```javascript
const express = require('express');
const app = express();

app.post('/webhook', express.json(), (req, res) => {
  const signature = req.headers['x-webhook-signature'];
  const isValid = verifyWebhook(req.body, signature, process.env.WEBHOOK_SECRET);
  
  if (!isValid) {
    return res.status(401).send('Invalid signature');
  }
  
  // Process webhook
  const { event_type, body } = req.body;
  console.log('Received event:', event_type, body);
  
  res.status(200).send('OK');
});
```

</CodeGroupItem>

<CodeGroupItem title="Python (Flask)">

```python
import hmac
import hashlib
import json
from flask import Flask, request, abort

app = Flask(__name__)
WEBHOOK_SECRET = 'your_webhook_secret'

def verify_webhook(payload, signature, secret):
    """Verify webhook signature"""
    expected_signature = 'sha256=' + hmac.new(
        secret.encode(),
        json.dumps(payload).encode(),
        hashlib.sha256
    ).hexdigest()
    
    return hmac.compare_digest(signature, expected_signature)

@app.route('/webhook', methods=['POST'])
def webhook():
    signature = request.headers.get('X-Webhook-Signature')
    payload = request.get_json()
    
    if not verify_webhook(payload, signature, WEBHOOK_SECRET):
        abort(401, 'Invalid signature')
    
    # Process webhook
    event_type = payload.get('event_type')
    body = payload.get('body')
    
    print(f'Received event: {event_type}', body)
    
    return 'OK', 200
```

</CodeGroupItem>
</CodeGroup>

<Warning>
Always use a constant-time comparison function like `crypto.timingSafeEqual()` to prevent timing attacks when comparing signatures.
</Warning>

## Implementation Guide

### Best Practices

1. **Idempotency**  
   Design your webhook handler to handle duplicate events gracefully.

2. **Queue Processing**  
   For long-running operations, queue the event and respond immediately.

3. **Error Handling**  
   Implement proper error handling and logging for all webhook events.

### Testing

Test your webhook endpoint using our [Webhook Tester](https://callintel.com/webhook-tester) or by sending test events.

## Troubleshooting

<Note>
If you encounter issues, check your endpoint's logs for detailed error messages.
</Note>

### Common Issues

- **Timeout Errors**  
  Ensure your endpoint responds within 5 seconds.

- **Signature Mismatch**  
  Verify your webhook secret and signature calculation.

- **HTTP Errors**  
  Your endpoint should return 2xx status codes for successful processing.

## Need Help?

For additional support with webhooks, contact our [support team](mailto:support@callintel.com).
